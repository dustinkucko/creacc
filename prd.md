# PRD (Product Requirements Document)

**Status:** Draft v1

---

## 1) Summary & Vision
- **Problem:** Creative teams need to collaborate on projects with agents
  - UI and server to benefit from Git without directly touching it, tracking creative commits over time.
  - Organize and catalog files and projects.
  - Build a knowledge graph.
- **Solution:** A web experience that connects brand copy (Markdown/HTML) and media assets inside spaces.
- **Spaces:** Personal and organizational owners; contain campaigns, creatives, collections, products, prompts, templates, and narratives; enable confident human–agent collaboration.

- Core principles
  - Git repositories are the foundational units of content and context.
  - Provide a familiar filesystem UI while preserving authoritative history.
  - Agents and humans check out, generate material, and check in with clear provenance.
  - Git hooks, automated manifests, and agent workflows keep copy and assets aligned across commits.

### Phasing
  - Phase 1: Focus on projects and collaboration.
  - Phase 2: Expand into catalogs and the knowledge graph.

### Abstractions & Definitions
- **Repository**
  - Comparable to the content of a book
  - A Git repository containing files and folders for a creative project; a block of creative work.
- **Commit** & **Release**
  - Comparable to the edition of the content of a book
- **Project**
  - Comparable to the content and context of a book (repository with additional metadata and artifacts)
  - A block of creative work managed with contextual domain metadata and policies (i.e. ULIDs/UUIDs, tags, manifests, leases/lock rules, UI/workflow semantics)
- **Catalog**
  - Comparable to the library catalog referencing the book (repository with submodules)
  - A collection of projects with additional metadata and indexing for discovery and provenance.
    - Enables knowledge graph construction (including APIs).
- **Space**
  - Comparable to the physical space where the library is located and the book is stored
  - A tenancy/ownership envelope that groups projects and catalogs.

### Customer Focus
- People using Google Drive with Midjourney and Adobe Creative Cloud Libraries.

---

## 2) Goals
- Product promise
  - Be the simplest, easiest Git‑backed creative platform to understand and use.
  - Prioritize clarity, predictability, and reliability in every interaction.

- Experience
  - UX: Enable creatives to manage files and folders without touching Git.
  - DX: Enable developers to extend repositories via OIDs, APIs, and mirrors.

- Git model
  - Treat each repository as a first‑class entity.
  - Auto‑initialize Git for new projects; the server manages all Git operations.
  - Preserve Git‑accurate SHA‑1 and SHA‑256 OIDs for blobs, trees, and commits.

- Workflow
  - [Check Out & Check In](#13-check-out--check-in) with exclusive leases and sparse paths selected in the UI.
  - Plain text/code in normal Git for readable diffs.
  - Track binaries and large files via Git LFS.

- Catalog
  - Generate a compact, append‑friendly catalog suitable for a knowledge graph.

---

## 3) Users & Personas
- **Creative Professional** uploads/downloads files/folders to edit copy/assets; requires simplicity.
- **Developer** enables functionality and automation using OIDs, APIs, and mirrors; requires extensibility.
- **Administrator** manages projects and catalogs with leases and evictions; audits history; curates catalog.

---

## 4) High‑Level Architecture (v1)
- **Git Server** — canonical bare repos for storage, ephemeral worktrees for compute and API access.
- **Commits** — one commit per check‑in; remote/HEAD is the catalog-indexed reference.
- **Web App** — [check out & check in](#13-check-out--check-in), sparse path selection, conflict resolution, and audit.
- **Catalog emitter** — writes per‑project JSONL shards.
- **Knowledge Graph** — consumers ingest the catalog; projects and commits provide data to build graph nodes and edges.
- **Consistent Hashing Ring** — dual SHA‑1/SHA‑256 ring for Git objects and repositories.

See [§1 Abstractions & Definitions](#abstractions--definitions) for terms; behavior details live in [§6 Git & LFS Behavior](#6-git--lfs-behavior), [§11 Hashing & Identity](#11-hashing--identity-git-accurate), and [§14 Catalog Layout](#14-catalog-layout-v1).

---

## 5) Repository Model
- Repositories, Projects, and Catalogs all reside under a Space (`/space/<space_id>/`).
- **Immutable ID:** `repository_id` is a **ULID or UUID v7** that is sortable by time and stable across renames/moves.
- Repositories can be created from uploaded directories (files and folders).
  - A `.yaml` configuration/context file can be generated by the server, which must pass validation.

`.yaml` (v1)
```yaml
repository_id: 01J9Z2Q3W8KFX8Q3R2A5V7YB1M    # ULID or UUID v7 (immutable)
name: "My Creative Project"                  # display name
created_at: "2025-10-14T13:00:00Z"           # set by server if absent
tags: ["campaign:Winter25", "client:Creacc"] # optional
description: "Optional one-liner."           # optional
```

---

## 6) Git & LFS Behavior
- **Auto-init:** If an uploaded project lacks `.git/`, server initializes a worktree repo (default branch `main`).
- **Server authority:** Client `.git/` must pass validation; server’s history is canonical.
  - **Commits:** Created by server on check‑in; include author/committer metadata.
  - Specific files and folders are uploaded/downloaded; no direct Git commands necessary.
  - File locking via Git LFS is supported for exclusive-edit assets.
- **Default branch scope:** Indexing of commits based on **default branch HEAD** only.
- **LFS policy:**
  - Track binaries/large types via `.gitattributes` (images/video/audio/archives/3D).
  - **Size-based auto-LFS:** enabled at **10 MB** for unknown types.
  - Text/code remain normal Git for diffs.
- **.gitattributes:** Installed by server in each project; ensures correct behavior in downstream clones.

**Extensions tracked by LFS (v1):** `png, jpg, jpeg, webp, gif, tiff, psd, ai, svgz, mp4, mov, mkv, wav, aiff, flac, mp3, ogg, zip, 7z, rar, tar, gz, bz2, blend, fbx, obj, glb, usdz`.

## 7) Content System Requirements
Creative engine that unifies content (copy/context) and assets so humans and agents can co-create within familiar workflows while Git preserves version history.

### Core Qualities
- **Human-friendly:** non-technical teammates can read, write, and edit comfortably.
- **Agent-friendly:** AI tooling (incl. MCP tool calls) can parse, edit, and validate content.
- **Markdown first:** Markdown with optional front matter (YAML/TOML/JSON) is the canonical format.
- **Versioned:** Git tracks history, diffs, and collaboration; Markdown remains the source of truth.
- **Open and portable:** minimal dependencies, no vendor lock-in.

### Media Referencing & Context
- Markdown documents reference media via keys/manifest entries rather than embedding binaries.
- Supports rich media references (social, web, marketing) with validation that links resolve to known assets.
- Campaign metadata (ULIDs/UUIDs, SKUs, ISO 8601 timestamps) binds copy to assets and downstream systems.

### Platform & Hosting
- Object storage migration path: Google Drive today → S3-compatible storage long term.
- Front-end hosting target: Cloudflare Workers / static delivery.
- Spaces may power static site generation, Shopify sync, and other downstream publishing flows.

### Automation & Validation
- Automated scripts keep manifests in sync, validate media references, and prevent orphaned assets.
- Agents/editors run deterministic tasks to edit Markdown, update manifests, and resolve URLs.
- Incremental builds and fast previews are desirable for editor experience.

### Nice-to-Haves
- Static site generator support (HTML/Liquid/MDX) for content publishing.
- Lightweight UI tailored to non-technical users while retaining power-user affordances.
- Shopify integration for automatic field updates.

## 8) Brand Repository
Centralized brand knowledge and asset metadata layer that pairs with creative tooling and downstream channels.

### Scope & Integrations
- Interfaces with social platforms, Shopify themes/stores, and internal creative tools.
- Houses assets, copy, guidelines, templates, prompts, and reusable patterns.
- Media binaries live in object storage; repo tracks Git LFS pointers and/or manifests referencing those objects.

### Naming & Identity Rules
- Use descriptive slugs (kebab-case or snake_case) derived from canonical names.
- Organize campaigns/creatives on timeline by timestamps (ISO 8601) plus metadata with tags.
- Assign ULIDs/UUIDs for sortable identifiers and SKUs for product linkage.
- Templates encapsulate reusable page/building-block structures.

### Automation & Governance
- CI/scripts validate manifests, enforce naming policies, and protect brand consistency.
- Guidelines and prompts remain versioned with the repo to align human and agent outputs.

## 9) Media & Content Storage
Defines how masters, derivatives, and manifests persist across Git and object storage using Git LFS as the connective tissue.

### Purpose
- Git LFS pointers keep repositories lean while S3-compatible object storage retains large masters.
- Balances creator UX (simple upload/manage) and developer UX (scriptable, reproducible, CI-friendly) without vendor lock-in.

### Core Requirements
- Git versioning for text/metadata; binaries tracked via Git LFS pointers.
- Vendor-agnostic object storage reachable via `rclone` and standard CLIs.
- Manifest-driven mapping lists masters (object keys, size, sha256) and deterministic derivatives.
- Deterministic derivations with captured commands for images/video/audio transforms.
- Derivatives committed to Git LFS for fast review and distribution readiness.
- LFS locking for exclusive-edit assets (PSD/AI and similar binaries).
- Creator UX supports drag-and-drop uploads, previews, and bulk operations.
- Developer UX supports scripted fetch/derive, partial fetch, caching, and CI validation.
- Integrity safeguards: checksums, metadata tracking, manifest validation.
- Scalability controls: storage lifecycle policies, cold storage tiers, CDN alignment.

### Workflow
1. Upload masters to object storage.
2. Update manifest with object keys, sizes, hashes, derivatives.
3. Fetch & derive locally or in CI using deterministic commands.
4. Commit derivatives to Git LFS and open PR for review.
5. CI validates manifest integrity, derivations, and build outputs; publish via CDN.

### Tooling
- `rclone` remote config, ImageMagick/Sharp, ffmpeg, Git LFS (with locking), hash/checksum validators, manifests, scripts, templates.

## 10) Asset Coordination Insights
Summarizes user expectations for creative asset systems to ensure our solution addresses mainstream needs.

### Core Needs
- Central source of truth housing assets and their variants.
- Fast findability through tags, collections, search, previews, and metadata.
- Versioning and approvals that capture edits, comments, comparisons, and sign-offs.
- Brand consistency enforced via brand kits, locked styles, fonts, and color tokens.
- Reusable building blocks (templates, components, snippets) for rapid production.
- Multi-format output: auto-resize, smart crops, file presets, and exports.
- Integrations into social, CMS, ad platforms, and developer handoffs.
- Collaboration controls: roles, share links, external reviewer access.
- Rights/usage tracking: licenses, expirations, usage notes.
- Workflow automation: briefs, tasks, statuses, checklists, AI assist.
- Analytics/feedback loops: performance signals inform next iterations.
- Reliability and speed: quick uploads, conflict handling, offline sync.

---

## 11) Hashing & Identity (Git-accurate)
- **Consistent Hashing Ring:** Dual SHA‑1 and SHA‑256 ring for Git objects and repositories.
- **Dual OIDs:** Store both SHA‑1 and SHA‑256 OIDs for blobs, trees, and commits.
- **Canonical bytes:** Use Git object formats: `"blob <size>\0<content>"`, `"tree <size>\0<entries>"`, `"commit <size>\0<content>"`.
- **Trees:** Correct modes (`100644/100755/120000/040000`), bytewise sort, raw child IDs (20B for SHA‑1 tree; 32B for SHA‑256 tree).
- **Root tree:** Persist `root_tree_sha1` and `root_tree_sha256` for each commit for fast integrity checks.
- **Case & Unicode:** Reject sibling case collisions; **normalize paths to NFC** for identity and comparisons.

---

## 12) Remotes & Mirrors
- **Canonical remote:** `origin` (HTTPS) recorded as canonical.
- **Mirrors:** Additional remotes (e.g., GitHub) recorded in the same `repos.jsonl` stream with `is_canonical=false` and `order_index ≥ 1`.
- **Fields:** `remote_name, remote_url, remote_host, remote_path, is_canonical, order_index, default_branch, head_commit_sha1/sha256, uses_lfs`.

---

## 13) Check Out & Check In
**Leases**
- **Default duration:** 72h (customizable check out). No auto‑renew.
- **Reminder:** Notify user **2h before expiry**. No grace period.
- **Admin eviction:** Allowed.

**Check‑out**
- Scope options: **Full project** or **Sparse** with **explicit paths only** (UI selection).
- Server issues a lease: `{project_id, base_commit, scope_type, pathset[]}` and a download.

**Check‑in**
- User uploads full project, sparse subset, or individual files.
- Within **scope**, upload is an **authoritative snapshot** — adds/changes applied; missing entries flagged as **deletions** for explicit confirmation.
- Outside scope: untouched.
- If HEAD moved: **auto‑rebase** on current HEAD; conflicts handled in an **agent‑assisted UI** (LFS pointer choice: ours/theirs/keep both → auto‑rename).
- On success: commit created, HEAD advanced, lease closed, **auto‑tag** `release-<YYYYMMDD>-<HHMMss>-<short_sha>`.

**Audit**
- Persist `{who, when, base_commit, new_commit, scope, adds, mods, renames, deletes, resolutions}`.

---

## 14) Catalog Layout (v1)
- Append‑friendly, per‑project shards that combine commit metadata + file manifests.
- Append‑only JSONL format for easy streaming and ingestion.
- Emit/append immediately after a successful check‑in.

- **Repos stream:** `catalog/repos.jsonl` (one object per remote; `origin` first).
- **Projects directory:** `catalog/projects.jsonl` (light directory: `project_id, name, created_at, tags`).
- **Per‑project shard:** `catalog/projects/<project_id>.jsonl` — **mixed record types**
  - `{"type":"release", ...}` one row per commit (includes root tree OIDs, counts, scope info).
  - `{"type":"file", ...}` one row per file in that commit (blob OIDs, mode, size, mime, LFS flag).
- **Rollover:** Start `.../<project_id>.part2.jsonl` when a shard exceeds ~**256 MB**.
- **Integrity:** `total_files` in must match the number of files for that commit.

---

## 15) API Surface
TODO: GraphQL over REST

**Projects**
- `POST /projects` — create from a `.yaml` or server‑generated; returns `project_id`.
- `GET /projects/:project_id` — metadata + latest commit.

**Check Out**
- `POST /projects/:project_id/leases/:lease_id/check-out` — body `{scope: {type: "full"|"sparse", paths:[]}, duration_hours?}` → returns lease + download token.
- `GET /projects/:project_id/leases/:lease_id` — lease status.

**Check In**
- `POST /projects/:project_id/leases/:lease_id/check-in` — multipart (files or zip) + JSON ops (confirm deletions/renames). Returns new commit metadata.

**Catalog**
- `GET /catalog/repos.jsonl` — stream.
- `GET /catalog/projects.jsonl` — stream.
- `GET /catalog/projects/:id.jsonl` — stream (supports HTTP range for tailing).

---

## 16) Security, Privacy, Compliance
- Ignore client `.git/` to prevent history injection.
- Validate ULID/UUID, NFC path normalization, and case‑collision rules on ingestion.
- Size/type enforcement for LFS on server.
- Admin eviction for stuck leases; all actions audited.

---

## 17) Telemetry & Observability
- Metrics: [Check Out](#13-check-out--check-in) counts, average lease length, [Check In](#13-check-out--check-in) success rate, conflict rate, average [catalog](#14-catalog-layout-v1) append latency, LFS bytes stored.
- Logs: check in audit and conflict resolutions.

---

## 18) Edge Cases & Handling
- **Case collisions:** Block; require user resolution (choose/rename/keep both).
- **Unicode variants:** Normalize to NFC; reject names differing only by normalization.
- **Sparse uploads adding out‑of‑scope paths:** Warn; require scope extension.
- **Deletes:** Never silent; require explicit confirmation.
- **Multiple remotes:** `origin` canonical; mirrors appended with ordering.

---

## 19) Open Questions / Future Work
- **Spaces with multiple catalogs:** Introduce top‑level `catalog.yaml`, namespace isolation.
- **Per‑directory tree OIDs:** Store `trees/*.jsonl` for faster tree diffing.
- **Submodule‑backed catalog sharding:** Convert `catalog/projects/<id>` into submodules for scale/ACLs.
- **Advanced conflict tooling:** Visual diff previews for common creative formats; binary diff heuristics.
- **Background validation:** Periodic rehash to detect bit rot; verify root tree vs HEAD^{tree}.
- **Richer metadata:** Optional sidecar ingestion (`*.meta.json`, EXIF → normalized fields).

---

## 20) Phases
**Phase 1 — Foundations (3 sprints)**
- Project detection via `.yaml` (ULID/UUID validation + server generation).
- Auto-init Git repo; add `.gitattributes` as per policy.
- Basic lease [check out](#13-check-out--check-in); full‑project scope only.
- Auto‑rebase [check in](#13-check-out--check-in); agent UI for conflicts (text + LFS pointer choice).
- [Catalog](#14-catalog-layout-v1) writers: `repos.jsonl`, `projects.jsonl`, `projects/<id>.jsonl` (commit and file information).
- Auto‑tag releases.

**Phase 2 — Sparse, Polish, Mirrors, & API Hardening (3 sprints)**
- Sparse path selection (explicit paths) → sparse [check out](#13-check-out--check-in) and [check in](#13-check-out--check-in) with deletion confirmations.
- Unicode and case enforcement; admin eviction with pre‑expiry reminders.
- Catalog rollover; integrity verifier.
- Mirror functionality for repositories; refined repos stream; pagination/range streaming endpoints.

---

## 21) Acceptance Criteria (samples)
- Uploading a new valid `.yaml` auto‑creates a project structure; ULID/UUID remains stable through renames.
- Checking in a changed PNG (>10 MB) stores content in LFS; release captures both blob SHA‑1 and SHA‑256.
- Checking in with stale base commit triggers auto‑rebase; conflict UI resolves an LFS pointer by choosing ours/theirs; resulting release is committed and tagged.
- Catalog stream for the project includes a `release` record followed by exactly `total_files` `file` records; `root_tree_sha*` matches `git rev-parse HEAD^{tree}`.
